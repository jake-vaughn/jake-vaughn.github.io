---
title: Modifying EVM Bytecode Function Selectors   
date: 2022-10-24 8:00:00 +/-1111
author: Jake Vaughn
categories: [Posts]
tags: [evm, bytecode, function signatures, hashing, posts, function selectors]
---

## Overview:
As you may or may not know Function Selectors are the method by which interaction with EVM smart contracts is possible. Function Selectors are the hashed smart-contract function signatures. An example of this is the `transfer(address sender, uint256 amount)` and `withdraw(uint256 wad)` function signatures that are hashed with `keccak256` extracting the first 4 bytes giving us `0xa9059cbb` and `0x2e1a7d4d` respectively. If you are interested in example code, solidity by example has you covered [here](https://solidity-by-example.org/function-selector/). These function signatures and selectors are important to understand what the function's name is and what parameters are needed in order for the caller to provide the correct information and for the correct function to be called by the smart contract. In this post, I will go over how to change these function hashes of post compiled smart-contracts and some of the reasons someone might want to do this, or how it could potentially be used for nefarious not so pure intentions.

## My Usecase
So I believe this post will make a bit more sense if I give the context as to how I came to understand this was possible. If you wish to simply know how to do function selector modification feel free to skip down to the [Modifying Function Selectors](#modifying-function-selectors) section below.

As we all may know there are some incredibly smart people out there, especially in the blockchain space (maybe even you? 0_o) and these guys or gals have a big leg up when it comes to smart-contract design and efficiency. Safe to say I am not there yet so I need to get a little creative in order to compete in the space. To do this I thought "Hey if all bytecode is available on the network, why don't I just use already deployed smart-contract bytecode for my own purposes?" Now I know this might not be the most practical or safe idea as I am flying blind without source code, but for me, it is a great learning experience.

Because I am using unknown smart contracts it opens me up to a lot of vulnerabilities. As I do not fully know what the smart-contract code is capable of I can not fully trust it. To mitigate this risk I wanted to try and make my use of the code less obvious to would-be attackers. At first, I thought the best way would be to create another smart contract that would then call my first contract changing the function hashes used and making it difficult to detect with tools like etherscan. I quickly remembered while doing this that smart-contract addresses are not the same as normal user signing addresses and therefore functions that use `require _param1 == addr(_param1)` revert instantly. Back to the scratchboard.

I then thought "Hey hashed functions shouldn't care what their original names or parameters were! Hashes are usually a one-way operation. I should be able to in theory change them to anything I wanted and then call them with the new function hash." After thinking about this I did a little testing and found out "Hey it works! Well, sort of?" I found that some hex codes would work and others wouldn't, but I wasn't entirely sure why. See at the time I was only using [panoramix](https://github.com/palkeo/panoramix) to decompile the smart contracts, so I did not understand that the compiler does a small optimization for function calls. Upon using another decompiler at [ethervm.io](https://ethervm.io/decompile) I realized that the compiler finds the function hash that is numerically between the others and uses it to search for the matching function selector above and below it. Cutting the search time roughly in half.

An example of what I mean is below in the screenshot from ethervm.io, and if you are still confused I will explain more in the detailed section below. After I understood this I was able to change my function hashes, deploy my smart contracts, and hopefully, fingers crossed be undetected. That is until I learn enough to make my own robust smart contracts. ^_^

## Modifying Function Selectors
First, you are going to need the bytecode of your target contract that was used in the smart-contract creation. There are two types of bytecode usually named bytecode and deployed bytecode if you do not know the difference I suggest reading this medium post [The difference between bytecode and deployed bytecode](https://medium.com/coinmonks/the-difference-between-bytecode-and-deployed-bytecode-64594db723df). Next we will take our bytecode and put it into [ethervm.io](https://ethervm.io/decompile) to obtain the function hashes. For this example we are using are looking at an [MEV Bot smart contract](https://etherscan.io/address/0xa57bd00134b2850b2a1c55860c9e9ea100fdd6cf#code) on the Ethereum network. Take the deployed bytecode from etherscan and place it in the big text box at the bottom of ethervm.io or use the contract address and hit decompile.
Decompiled Mev Bot Contract by ethervm.io [Here](https://ethervm.io/decompile/0xa57Bd00134B2850B2a1c55860c9e9ea100fDd6CF)
> Note: Using the ethervm.io decompiler requires deployed bytecode as ethervm.io doesn't handle constructors well, but for the rest of this post we will be dealing 

with the bytecode used when sending the transaction to deploy the contract referred to as simply "bytecode".
![MEV Bot functions snippit](/images/modifyingBytecode/mevbotPublicMethods.png)
Now that we have our functions we can identify them in the hex-compiled smart-contract code aka the bytecode. For this example we are going to change `0x1cff79cd execute(address,bytes)`, `0x78e111f6 Unknown`, and `0x9c52a7f1 deny(address)`.

> Note: Bytecode can be found in the Input Date field of a transaction that created the smart contracts. For example the MEV bot's creation transaction [Here](https://etherscan.io/tx/0x0d8fc644c8178a352cd39aed1c3ae58434e422390c96f182b3fd68c53ec070e2)

**Full Bytecode**
```
0x608060405234801561001057600080fd5b50604051602080610d628339810180604052602081101561003057600080fd5b5051336000908152602081905260409020600190556100578164010000000061005e810204565b5050610114565b3360009081526020819052604081205460011461007a57600080fd5b600160a060020a03821615156100f157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f64732d70726f78792d63616368652d616464726573732d726571756972656400604482015290519081900360640190fd5b5060018054600160a060020a038316600160a060020a0319909116178155919050565b610c3f806101236000396000f3fe6080604052600436106100a3576000357c01000000000000000000000000000000000000000000000000000000009004806378e111f61161007657806378e111f6146102ec578063948f5076146104175780639c52a7f11461045e578063a90e873114610491578063bf353dbb146105be576100a3565b80631cff79cd146100a55780631f6a1eb91461015b57806360c7d2951461028857806365fae35e146102b9575b005b6100a3600480360360408110156100bb57600080fd5b600160a060020a0382351691908101906040810160208201356401000000008111156100e657600080fd5b8201836020820111156100f857600080fd5b8035906020019184600183028401116401000000008311171561011a57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610603945050505050565b6100a36004803603604081101561017157600080fd5b81019060208101813564010000000081111561018c57600080fd5b82018360208201111561019e57600080fd5b803590602001918460018302840111640100000000831117156101c057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929594936020810193503591505064010000000081111561021357600080fd5b82018360208201111561022557600080fd5b8035906020019184600183028401116401000000008311171561024757600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610645945050505050565b34801561029457600080fd5b5061029d610847565b60408051600160a060020a039092168252519081900360200190f35b3480156102c557600080fd5b506100a3600480360360208110156102dc57600080fd5b5035600160a060020a0316610856565b6103a26004803603604081101561030257600080fd5b600160a060020a03823516919081019060408101602082013564010000000081111561032d57600080fd5b82018360208201111561033f57600080fd5b8035906020019184600183028401116401000000008311171561036157600080fd5b91908080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092955061088f945050505050565b6040805160208082528351818301528351919283929083019185019080838360005b838110156103dc5781810151838201526020016103c4565b50505050905090810190601f1680156104095780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561042357600080fd5b5061044a6004803603602081101561043a57600080fd5b5035600160a060020a03166108fa565b604080519115158252519081900360200190f35b34801561046a57600080fd5b506100a36004803603602081101561048157600080fd5b5035600160a060020a03166109bd565b6103a2600480360360408110156104a757600080fd5b8101906020810181356401000000008111156104c257600080fd5b8201836020820111156104d457600080fd5b803590602001918460018302840111640100000000831117156104f657600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929594936020810193503591505064010000000081111561054957600080fd5b82018360208201111561055b57600080fd5b8035906020019184600183028401116401000000008311171561057d57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295506109f3945050505050565b3480156105ca57600080fd5b506105f1600480360360208110156105e157600080fd5b5035600160a060020a0316610c01565b60408051918252519081900360200190f35b3360009081526020819052604090205460011461061f57600080fd5b600080825160208401855af480156001811461063a5761063f565b600080fd5b50505050565b6001546040517f8bf4515c000000000000000000000000000000000000000000000000000000008152602060048201818152855160248401528551600094600160a060020a031693638bf4515c938893928392604401918501908083838b5b838110156106bc5781810151838201526020016106a4565b50505050905090810190601f1680156106e95780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561070657600080fd5b505afa15801561071a573d6000803e3d6000fd5b505050506040513d602081101561073057600080fd5b50519050600160a060020a0381161515610838576001546040517f7ed0c3b2000000000000000000000000000000000000000000000000000000008152602060048201818152865160248401528651600160a060020a0390941693637ed0c3b293889383926044909201919085019080838360005b838110156107bd5781810151838201526020016107a5565b50505050905090810190601f1680156107ea5780820380516001836020036101000a031916815260200191505b5092505050602060405180830381600087803b15801561080957600080fd5b505af115801561081d573d6000803e3d6000fd5b505050506040513d602081101561083357600080fd5b505190505b6108428183610603565b505050565b600154600160a060020a031681565b3360009081526020819052604090205460011461087257600080fd5b600160a060020a0316600090815260208190526040902060019055565b336000908152602081905260409020546060906001146108ae57600080fd5b600080835160208501865af43d6040519250601f19601f6020830101168301604052808352806000602085013e8115600181146108ea576108f1565b8160208501fd5b50505092915050565b3360009081526020819052604081205460011461091657600080fd5b600160a060020a038216151561098d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f64732d70726f78792d63616368652d616464726573732d726571756972656400604482015290519081900360640190fd5b5060018054600160a060020a03831673ffffffffffffffffffffffffffffffffffffffff19909116178155919050565b336000908152602081905260409020546001146109d957600080fd5b600160a060020a0316600090815260208190526040812055565b6001546040517f8bf4515c000000000000000000000000000000000000000000000000000000008152602060048201818152855160248401528551606094600094600160a060020a0390911693638bf4515c93899390928392604490910191908501908083838b5b83811015610a73578181015183820152602001610a5b565b50505050905090810190601f168015610aa05780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b158015610abd57600080fd5b505afa158015610ad1573d6000803e3d6000fd5b505050506040513d6020811015610ae757600080fd5b50519050600160a060020a0381161515610bef576001546040517f7ed0c3b2000000000000000000000000000000000000000000000000000000008152602060048201818152875160248401528751600160a060020a0390941693637ed0c3b293899383926044909201919085019080838360005b83811015610b74578181015183820152602001610b5c565b50505050905090810190601f168015610ba15780820380516001836020036101000a031916815260200191505b5092505050602060405180830381600087803b158015610bc057600080fd5b505af1158015610bd4573d6000803e3d6000fd5b505050506040513d6020811015610bea57600080fd5b505190505b610bf9818461088f565b949350505050565b6000602081905290815260409020548156fea165627a7a72305820d2cb37091b9fea78618babf87ea1e2213f2acdaa5676752f200e6d4bdd52ab080029000000000000000000000000f3c9d00c06e6ceef470510ed599bd30569a2ddc6
```
**BYTECODE With Functions Highlighted**
0x608060405234801561001057600080fd5b50604051602080610d628339810180604052602081101561003057600080fd5b5051336000908152602081905260409020600190556100578164010000000061005e810204565b5050610114565b3360009081526020819052604081205460011461007a57600080fd5b600160a060020a03821615156100f157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f64732d70726f78792d63616368652d616464726573732d726571756972656400604482015290519081900360640190fd5b5060018054600160a060020a038316600160a060020a0319909116178155919050565b610c3f806101236000396000f3fe6080604052600436106100a3576000357c010000000000000000000000000000000000000000000000000000000090048063`78e111f6`11610076578063`78e111f6`146102ec578063948f507614610417578063`9c52a7f1`1461045e578063a90e873114610491578063bf353dbb146105be576100a3565b8063`1cff79cd`146100a55780631f6a1eb91461015b57806360c7d2951461028857806365fae35e146102b9575b005b6100a3600480360360408110156100bb57600080fd5b600160a060020a0382351691908101906040810160208201356401000000008111156100e657600080fd5b8201836020820111156100f857600080fd5b8035906020019184600183028401116401000000008311171561011a57600080fd5b919080806…

> Note: 78e111f6 gets used twice in the bytecode we will change both.

**Changing the Functions**
We can then change the 4-byte function selectors to any desired 4-bytes we want with one big exception. Depending on how the bytecode is compiled, the compiler will optimize in order to call functions faster. If the bytecode you are changing has a small number of functions you can ignore this and the next paragraph, but this is often not the case. For an example of the difference check out the decompiled [Weth9](https://ethervm.io/decompile/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) contract vs our [example Mev Bot](https://ethervm.io/decompile/0xa57Bd00134B2850B2a1c55860c9e9ea100fDd6CF). Notice in the code of the Decompilation section that Weth9 compares var0 to find the equal function selector right off the bat, while our example starts with an `if (0x78e111f6 > var0)`. This is because the MevBot contract was optimized to lookup functions with less gas. Because of this fact, we must work around the optimization.

In our example, the new function we pick must be smaller than or greater than the numerical midpoint function depending on if the original function was smaller or greater than the original midpoint function. For example in our smart contract above `0x78e111f6` is the midpoint function and if we want to replace a function like say `0x1cff79cd` we would need to pick a hex number smaller than `0x78e111f6`. If we want to change `0x9c52a7f1` we would need to change it to a hex number larger than `0x78e111f6`. This can be circumvented by also changing the midpoint function, but keep in mind that because the bytecode has already been compiled it will not change the order nor which functions are greater than or less than the midpoint function. For example, if I change the midpoint to the largest number possible `0xffffffff` then I can choose any new hash function for `0x1cff79cd`, but I will not be able to use any hex number for `0x9c52a7f1`. This is because there is no function that I can choose that is greater than `0xffffffff`. The same goes if I make the midpoint `0x00000000`. Only functions that were originally bigger than the original midpoint would be changeable. It should also be noted that changing two or more hashes to the same hash results in unique scenarios and is most likely not desirable.

Now that we have changed one or all of the function hashes keeping in mind the exceptions above, we can deploy the smart contract using any tool that allows us to send a transaction with the data field. My favorites for quick deployment are [ethersJS](https://docs.ethers.io/v5/) with [hardhat](https://hardhat.org/) and [0xPhaze's ABI Playground](https://lovethewired.github.io/abi-playground). All you need to do then is to wait for your transaction to be mined and use your contract with the new function hashes. I currently call functions by creating my own transaction data but there might be a better more user-friendly way using hardhat, for now, it works. Once called functions will do the exact same thing as the original but will have a different function selector.

## Real-World Implications
Okay now for the real question. Why would anyone want to do this? Well if you didn't read the [My Usecase](#my-usecase) section then I believe the main use would be to obfuscate what your smart-contract functions are and what they do. There are databases with well-known functions such as the [4byte database](https://www.4byte.directory/) which has a large number of hash functions for look-up sourced from verified code and GitHub projects. These databases make it easy to see what functions are used by a smart contract and enable you to interact with them without the source code. If you want to make it even harder for others to identify and potentially attack your contracts this is a great way to make detection and interaction much more difficult.

Another implication is the potential unintended or intended malicious use of this knowledge. Because we can change the function hash to any other that we choose, there is nothing stopping us from changing them to common functions found in the databases. This could be a problem if you were to trust a contract purely based on the function name showing up in a service like etherscan, metamask, or any other wallet provider. Etherscan will only look at the function hash in the data field of a transaction and assign the name of the function without the contract being verified. There are also other ways of doing this by creating a function with the same name and parameters in the source code. Anyone aware that this is possible shouldn't be susceptible to this trick, but to those using and trusting tools, this could present a vulnerability and should be kept in mind.

The last reason I can come up with that anyone would want to do this is simply for fun. You can make any function look like another. I could have a swapping function saying that it is withdrawing but actually secretly swapping. I could have a function that looks like it only has one uint256 parameter, but actually needs 7 different variables: uint8, bytes, account arrays, etc. The only other way I can see changing the number of parameters of a function without changing the hash or name is by hashing a bunch of functions with different names to get a collision with the target function. There are many unique things that you can do by modifying bytecode, many of which I have not yet thought of yet. Let me know if you come up with anything fun.

## Conclusion
I hope you enjoyed this novel look into modifying post-compiled EVM bytecode function selectors. I could not find any other post about this subject matter on the internet so I decided to post this. Feel free to message me if someone else has already detailed this, you have any questions, or want to give me feedback. Thanks for reading!

> P.S. I recommend giving this a try out yourself with tools such as [ethersJS](https://docs.ethers.io/v5/) with [hardhat](https://hardhat.org/) or [0xPhaze's ABI Playground](https://lovethewired.github.io/abi-playground) and see what you can do.

